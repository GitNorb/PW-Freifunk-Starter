<?php

/**
 * A field that stores events each with a date, location and notes
 *
 * This is an example of creating your own Fieldtype to represent a spreadsheet type table of information.
 *
 */

class FieldtypeNodeInfo extends Fieldtype {

	public static function getModuleInfo() {
		return array(
			'title' => 'Node Info',
			'version' => 001,
			'summary' => __('Field that stores a table of events for a page.'),
      'author' => 'Sebastian Preisner',
      'href' => '',
			'installs' => 'InputfieldNodeInfo',
			);
	}

	/**
	 * Initialize this Fieldtype
	 */
	public function init(){
		parent::init();
		$dir = dirname(__FILE__);
		require_once("$dir/NodeInfo.php");
	}

	/**
	 * Return the required Inputfield used to populate a field of this type
	 */
	public function getInputfield(Page $page, Field $field) {
		$inputfield = $this->modules->get("InputfieldNodeInfo");

		// our inputfield requires a Page and Field (I don't know if it is correct)
		$inputfield->setPage($page);
		$inputfield->setField($field);

		return $inputfield;
	}

	/**
	 * Return a blank ready to populate version of this fieldset
	 */
	public function getBlankValue(Page $page, Field $field){
		$nodeinfo = new NodeInfo();
		$nodeinfo->setTrackChanges(true);
		return $nodeinfo;
	}

	/**
	 * Give a raw value (value as stored in DB)
	 *
   * @param Page $page
   * @param Field $field
   * @param string|int|array $value
   * @return string|int|array|object $value
	 */
	public function __wakeupValue(Page $page, Field $field, $value) {

		// if for some reason we already get a valid value, then just return it
		if($value instanceof NodeInfo) return $value;

		// start a blank value to be populated
		$nodeinfo = $this->getBlankValue($page, $field);

		// if we were given a blank value, then we've got nothing to do: just return a blank NodeInfo
		if(empty($value) || !is_array($value)) return $nodeinfo;

		$nodeinfo->resetTrackChanges();

		return $nodeinfo;

	}

	/**
	 * Given an 'awake' value, as set by wakeupValue, convert the value back to a basic type for storage in DB.
	 *
	 * @param Page $page
   * @param Field $field
   * @param string|int|array|object $value
   * @return string|int
	 */
	public function ___sleepValue(Page $page, Field $field, $value) {
		$sleepValue = array();

		// if we are given somthing other than an NodeInfo,
		// then just return a blank value
		if(!$value instanceof NodeInfo) return $sleepValue;

		// set NodeInfo to an array within sleepValue
		$sleepValue = array(
			'ipv6' => $value->ipv6,
			'lastconnect' => $value->lastconnect,
			'hardware' => $value->hardware,
			'firmware' => $value->firmware,
			'lat' => $value->lat,
			'long' => $value->long,
			'address' => $value->address,
			'online' => $value->online
		);

		return $sleepValue;
	}

	/**
	 * Give a value make it clean for storage within a Page
	 */
	public function sanitizeValue(Page $page, Field $field, $value){
		// if given a blank value, return a valid blank value
		if(empty($value)) return $this->getBlankValue($page, $field, $value);

		// if given somthing other than an NodeInfo, throw an Error
		if(!$value instanceof NodeInfo) {
			throw new WireException("Value set to field '$fied->name' must be an NodeInfo");
		}

		// note that sanitization of individual fields within a given event is already
		// performed by the NodeInfo::set() methode, so we don't need to do anything else here.
		return $value;
	}

	/**
	 * Format a value for output, called when a Page's outputFormatting is on
	 *
	 */
	public function formatValue(Page $page, Field $field, $value) {
		// we actually don't need to do anything in here since each NodeInfo object
		// is doing this work in the NodeInfo::get() method. But I've included this
		// comment here just to explain where that is taking place.
		return $value;
	}

	/**
	 * Return the database schema that defines an NodeInfo
	 */
	public function getDatabaseSchema(Field $field){
		$schema = parent::getDatabaseSchema($field);

		// 'data' is a required field for any Fieldtype
		// we use it to represent our 'lastconnect' field
		$schema['data'] = 'INT NOT NULL DEFAULT 0';

		// our text fields
		$schema['ipv6'] = 'TINYTEXT NOT NULL';
		$schema['lastconnect'] = 'TINYTEXT NOT NULL';
		$schema['hardware'] = 'TEXT NOT NULL';
		$schema['firmware'] = 'TINYTEXT NOT NULL';
		$schema['lat'] = 'TINYTEXT NOT NULL';
		$schema['long'] = 'TINYTEXT NOT NULL';
		$schema['address'] = 'TEXT NOT NULL';

		// our boolean field
		$schema['online'] = 'TINYINT NOT NULL DEFAULT 0';
		// indexes, for any fields that need to be searchable from
		// selectors in this case, we're just making our '' field
		// searchable but the others could easily be addad, likely
		// as fulltext indexes

		return $schema;
	}

	/**
	 * Method called when the field is database-queried from a selectors
	 *
	 */
	public function getMatchQuery($query, $table, $subfield, $operator, $value){

		// If searching 'lastconnect' then assume our default (data) field
		if($subfield == 'lastconnect') $subfield = 'data';

		// if value is a formatted date, convert it to unix timestamp
		if(!ctype_digit("$value")) $value = strtotime($value);

		return parent::getMatchQuery($query, $table, $subfield, $operator, $value);

	}
}
